"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[2990],{5625:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>c,frontMatter:()=>r,metadata:()=>o,toc:()=>d});var s=i(5893),t=i(1151);const r={sidebar_position:6},a="Method files",o={id:"user_guide/fitting/method_files",title:"Method files",description:"Description",source:"@site/docs/user_guide/fitting/method_files.md",sourceDirName:"user_guide/fitting",slug:"/user_guide/fitting/method_files",permalink:"/ChemEx/docs/user_guide/fitting/method_files",draft:!1,unlisted:!1,editUrl:"https://github.com/gbouvignies/chemex/tree/main/website/docs/user_guide/fitting/method_files.md",tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6},sidebar:"tutorialSidebar",previous:{title:"Parameter files",permalink:"/ChemEx/docs/user_guide/fitting/parameter_files"},next:{title:"Kinetic models",permalink:"/ChemEx/docs/user_guide/fitting/kinetic_models"}},l={},d=[{value:"Description",id:"description",level:2},{value:"Example",id:"example",level:2},{value:"Setting parameter behavior",id:"setting-parameter-behavior",level:2},{value:"<code>FIT</code>",id:"fit",level:3},{value:"<code>FIX</code>",id:"fix",level:3},{value:"<code>CONSTRAINTS</code>",id:"constraints",level:3},{value:"Selecting a subset of profiles",id:"selecting-a-subset-of-profiles",level:2},{value:"<code>INCLUDE</code>",id:"include",level:3},{value:"<code>EXCLUDE</code>",id:"exclude",level:3},{value:"Running a grid search",id:"running-a-grid-search",level:2},{value:"Evaluating the uncertainty on the fitted parameters",id:"evaluating-the-uncertainty-on-the-fitted-parameters",level:2},{value:"Monte Carlo simulations",id:"monte-carlo-simulations",level:3},{value:"Bootstrap analysis",id:"bootstrap-analysis",level:3},{value:"Nucleus-specific bootstrap analysis",id:"nucleus-specific-bootstrap-analysis",level:3},{value:"Syntax",id:"syntax",level:3}];function h(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"method-files",children:"Method files"}),"\n",(0,s.jsx)(n.h2,{id:"description",children:"Description"}),"\n",(0,s.jsx)(n.p,{children:"The method file contains the fitting methods to be used during the fitting\nprocess. This is where you can:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"define which parameters are fit, fixed, or constrained,"}),"\n",(0,s.jsx)(n.li,{children:"select the profiles to include in the calculation,"}),"\n",(0,s.jsx)(n.li,{children:"activate additional calculations, such as grid search, Monte Carlo or\nbootstrap analyses."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["This file is provided to ChemEx using the ",(0,s.jsx)(n.code,{children:"-m"})," or ",(0,s.jsx)(n.code,{children:"--method"})," option."]}),"\n",(0,s.jsx)(n.p,{children:"The method file is structured in sections. Each section corresponds to a fitting\nstep. The section name is the name of the fitting step. The steps are run in the\norder they are defined."}),"\n",(0,s.jsx)(n.p,{children:"If the fitting method contains multiple fitting steps, the value and behavior of\neach parameter always inherit from the previous fitting step if not set in the\ncurrent step. This means that if a parameter is fixed in one step, it remains\nfixed in the following steps as long as its state is not changed."}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsxs)(n.p,{children:["The set of residues to be included in global fits should be chosen carefully. A\ncommonly used multi-step fitting strategy is to select a subset of residues with\nrelatively large CPMG dispersion or good quality CEST minor dips to first get\nglobal parameters (p",(0,s.jsx)("sub",{children:"B"}),", k",(0,s.jsx)("sub",{children:"ex"}),"), and then carry out\nsingle-residue fits with (p",(0,s.jsx)("sub",{children:"B"}),", k",(0,s.jsx)("sub",{children:"ex"}),") fixed to get\nresidue-specific parameters (e.g., \u0394\u03d6) in the next step. In CPMG experiments, to\nget reasonable initial estimates of \u0394\u03d6 for each residue, an additional\nsingle-residue fitting step can be carried out at the very beginning, see the\nmethod file for ",(0,s.jsx)(n.code,{children:"CPMG_CH3_1H_SQ/"})," under ",(0,s.jsx)(n.code,{children:"Examples/Experiments/"})," for such an\nexample."]})}),"\n",(0,s.jsx)(n.h2,{id:"example",children:"Example"}),"\n",(0,s.jsx)(n.p,{children:"Here is an example method file demonstrating the different possibilities:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-toml",metastring:'title="method.toml"',children:'[STEP1]\nINCLUDE = [15, 31, 33, 34, 37]                                                                                              #, 33, 34, 37]\nGRID    = [\n    "[KEX_AB] = log(100.0, 600.0, 10)",\n    "[PB] = log(0.03, 0.15, 10)",\n    "[DW_AB] = lin(0.0, 10.0, 5)",\n]\n\n[STEP2]\nFIT = ["PB", "KEX_AB", "DW_AB"]\nSTATISTICS = { "MC"=100, "BS"=100, "BSN"=100 }\n\n[STEP3]\nINCLUDE = "ALL"\nFIX     = ["PB", "KEX_AB"]\nGRID    = ["[DW_AB] = lin(0.0, 10.0, 20)"]\n\n[STEP4]\nFIT = ["DW_AB"]\n\n'})}),"\n",(0,s.jsx)(n.p,{children:"This fit contains 4 distinct steps:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["A subset of profiles are selected, and a grid search is performed on the\nparameters ",(0,s.jsx)(n.code,{children:'"KEX_AB"'}),", ",(0,s.jsx)(n.code,{children:'"PB"'})," and ",(0,s.jsx)(n.code,{children:'"DW_AB"'}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["The parameters ",(0,s.jsx)(n.code,{children:'"KEX_AB"'}),", ",(0,s.jsx)(n.code,{children:'"PB"'})," and ",(0,s.jsx)(n.code,{children:'"DW_AB"'})," are set to vary. The\nselection of profiles remains the same as in the first step."]}),"\n",(0,s.jsxs)(n.li,{children:["All profiles are included in the fit, the parameters ",(0,s.jsx)(n.code,{children:'"KEX_AB"'})," and ",(0,s.jsx)(n.code,{children:'"PB"'}),"\nare fixed, and a grid search is performed on the parameter ",(0,s.jsx)(n.code,{children:'"DW_AB"'}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["The parameter ",(0,s.jsx)(n.code,{children:'"DW_AB"'})," is set to vary."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Results are written on separate directories named according to the corresponding\nsection name."}),"\n",(0,s.jsx)(n.h2,{id:"setting-parameter-behavior",children:"Setting parameter behavior"}),"\n",(0,s.jsx)(n.p,{children:"All model parameters can either be varied, fixed or constrained. The status of\neach parameter is defined by default at the beginning of the fitting process.\nHowever, you can change this behavior in each fitting step of the method file."}),"\n",(0,s.jsx)(n.h3,{id:"fit",children:(0,s.jsx)(n.code,{children:"FIT"})}),"\n",(0,s.jsxs)(n.p,{children:["Parameters in the ",(0,s.jsx)(n.code,{children:"FIT"})," list are varied during the fitting process. Here,\nparameter names can either designate a unique parameter or a group of\nparameters. For the later, simply mention the attributes identifying the group."]}),"\n",(0,s.jsx)(n.p,{children:"For example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-toml",children:'FIT = [\n    "R2_A, NUC->G23N, B0->800.13MHz, T->23C",\n    "R1_A, B0->800.13MHz",\n    "DW_AB, NUC->N",\n    "R2_B",\n]\n'})}),"\n",(0,s.jsx)(n.p,{children:"In this example:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:'"R2_A, NUC->G23N, B0->800.13MHz, T->23C"'})," corresponds to the amide nitrogen\nR",(0,s.jsx)("sub",{children:"2"})," of state A of Gly23 measured at 23 \xbaC, 800.13 MHz."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:'"R1_A, B0->800.13MHz"'})," selects all the state A R",(0,s.jsx)("sub",{children:"1"})," values measured\nat 800.13 MHz, independently of the residue number and temperature."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:'"DW_AB, NUC->N"'})," corresponds to all the amide nitrogen chemical shift\ndifferences between states A and B ."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:'"R2_B"'})," selects all R",(0,s.jsx)("sub",{children:"2"})," values os state B."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"fix",children:(0,s.jsx)(n.code,{children:"FIX"})}),"\n",(0,s.jsxs)(n.p,{children:["Parameters in the ",(0,s.jsx)(n.code,{children:"FIX"})," list are fixed during the fitting process. The format is\nsimilar to the ",(0,s.jsx)(n.code,{children:"FIT"})," list."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-toml",children:'FIX = [\n    "R2_A, NUC->G23N, B0->800.13MHz, T->23C",\n    "R1_A, B0->800.13MHz",\n    "DW_AB, NUC->N",\n    "R2_B",\n]\n'})}),"\n",(0,s.jsx)(n.h3,{id:"constraints",children:(0,s.jsx)(n.code,{children:"CONSTRAINTS"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"CONSTRAINTS"})," list defines the constraints to be applied to the parameters.\nConstraints are mathematical expression of other parameters. The value of the\nconstrained parameter is calculated using this expression."]}),"\n",(0,s.jsxs)(n.p,{children:["Parameters in the mathematical expression given in the ",(0,s.jsx)(n.code,{children:"CONSTRAINTS"})," list should\nbe put in brackets."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-toml",children:'CONSTRAINTS = [\n    "[R1_B] = 0.5 * [R1_A]",\n    "[R2_B, NUC->N] = [R2_A, NUC->N]",\n]\n'})}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:["Keys are read in that order: ",(0,s.jsx)(n.code,{children:"CONSTRAINTS"})," -> ",(0,s.jsx)(n.code,{children:"FIX"})," -> ",(0,s.jsx)(n.code,{children:"FIT"}),"."]})}),"\n",(0,s.jsx)(n.h2,{id:"selecting-a-subset-of-profiles",children:"Selecting a subset of profiles"}),"\n",(0,s.jsx)(n.h3,{id:"include",children:(0,s.jsx)(n.code,{children:"INCLUDE"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"INCLUDE"})," key in method file allows selecting a subset of residues for\nanalysis during each fitting step. The residue name should match the spin-system\nassignment provided in the experiment file(s). You can use the full spin-system\nname (e.g. ",(0,s.jsx)(n.strong,{children:'"G23N-H"'}),") or the group name (e.g. ",(0,s.jsx)(n.strong,{children:'"G23"'}),") or the residue\nnumber (e.g. ",(0,s.jsx)(n.strong,{children:"23"}),"). ",(0,s.jsx)(n.code,{children:'"ALL"'})," (or ",(0,s.jsx)(n.code,{children:'"*"'}),") is the default value, which indicates\nthat all residues are to be included in the current fitting step."]}),"\n",(0,s.jsxs)(n.admonition,{type:"note",children:[(0,s.jsx)(n.p,{children:"When only the residue number is used, use a list of integer, that is omit the\nquotes. These two formulations are equivalent:"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-toml",children:'INCLUDE = ["G2", "A4", "C5", "H6"]\nINCLUDE = [2, 4, 5, 6]\n'})})]}),"\n",(0,s.jsx)(n.h3,{id:"exclude",children:(0,s.jsx)(n.code,{children:"EXCLUDE"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"EXCLUDE"})," key in method file allows excluding a subset of residues from\nanalysis during each fitting step. its usage is similar to the ",(0,s.jsx)(n.code,{children:"INCLUDE"})," key."]}),"\n",(0,s.jsx)(n.h2,{id:"running-a-grid-search",children:"Running a grid search"}),"\n",(0,s.jsxs)(n.p,{children:["ChemEx has a built-in grid search method that offers the possibility to run an\nnD grid search and plot the resulting \u03c7",(0,s.jsx)("sup",{children:"2"})," values as 1D and 2D plots.\nGrid search can be defined and run using the key ",(0,s.jsx)(n.code,{children:"GRID"})," in any section of the\nmethod file."]}),"\n",(0,s.jsxs)(n.p,{children:["The grid is defined on a parameters basis. The parameters defining the nD grid\nare fixed to the value of the grid that is evaluated, while the other parameters\nare set as defined by the ",(0,s.jsx)(n.code,{children:"FIX"}),", ",(0,s.jsx)(n.code,{children:"FIT"})," and ",(0,s.jsx)(n.code,{children:"CONSTRAINTS"})," options. Points of the\ngrid can be defined using a linear scale, a log scale or point by point:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Linear scale:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-toml",children:'"[PB] = lin(<min>, <max>, <nb of points>)"\n'})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Log scale:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-toml",children:'"[PB] = log(<min>, <max>, <nb of points>)"\n'})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Point by point:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-toml",children:'"[PB] = (<value1>, <value2>, ..., <valuen>)"\n'})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-toml",children:'GRID = [\n    "[PB] = log(0.03, 0.1, 10)",\n    "[KEX_AB] = log(200.0, 1000.0, 10)",\n    "[DW_AB] = lin(0.0, 10.0, 10)",\n]\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Parameters are selected as usual. For example, ",(0,s.jsx)(n.code,{children:"[R2_A]"})," would select all the\n",(0,s.jsx)(n.strong,{children:"R2_A"}),". ",(0,s.jsx)(n.code,{children:"[R2_A, NUC->G43N]"})," would select all the ",(0,s.jsx)(n.strong,{children:"R2_A"})," parameters of the\nnucleus ",(0,s.jsx)(n.strong,{children:"G43N"})," (multiple values if there are several temperatures, B0 field)."]}),"\n",(0,s.jsxs)(n.p,{children:["At the end of the grid search the best point is selected and the corresponding\nparameters are used in the next step of the fitting procedure. The \u03c7",(0,s.jsx)("sup",{children:"2"}),"\nvalues are reported in the ",(0,s.jsx)(n.code,{children:"grid.toml"})," file as well as in the form of 1D and 2D\nplots."]}),"\n",(0,s.jsxs)(n.p,{children:["For an nD grid with n > 1, multiple 1D grids are plotted, one per parameter,\ncorresponding to the parameter values on the x axis and the minimum\n\u03c7",(0,s.jsx)("sup",{children:"2"})," value along the other dimension."]}),"\n",(0,s.jsxs)(n.p,{children:["Similarly, if n > 2, then a series of 2D \u03c7",(0,s.jsx)("sup",{children:"2"})," surface corresponding to\neach pair of independent parameters is plotted. 2D surface correspond to 2D\nprojection in which the best fit values in the other dimensions are used to\nevaluate each point."]}),"\n",(0,s.jsxs)(n.admonition,{type:"info",children:[(0,s.jsxs)(n.p,{children:["When two parameters are independent from each others, the corresponding\n\u03c7",(0,s.jsx)("sup",{children:"2"})," surface is entirely flat. It then becomes possible to define\nsub-grids of parameters that are all dependent on each others. The algorithm\nused in ChemEx starts by defining these minimal individual grids and then\nevaluates them separately. The evaluated sub-grids may share common parameters.\nThey are therefore combined together at the end to recover the global minimum\nand to plot 1D \u03c7",(0,s.jsx)("sup",{children:"2"})," curve for each parameter and 2D plots when\npossible."]}),(0,s.jsx)(n.p,{children:"This algorithm is much faster in the sense that a search involving 2 global\nparameters and 8 independent residue specific parameters does not generate a\n10-dimensional grid, but 10 3-dimensional grids, which is much faster and\nimportantly retains all the information."})]}),"\n",(0,s.jsx)(n.h2,{id:"evaluating-the-uncertainty-on-the-fitted-parameters",children:"Evaluating the uncertainty on the fitted parameters"}),"\n",(0,s.jsx)(n.p,{children:"The uncertainty on fitted parameters is, in general, estimated through the\ncovariance matrix obtained from the Levenberg-Marquardt optimization. However,\nChemEx offers additional methods to evaluate the parameter uncertainties, that\nis, Monte Carlo simulation, bootstrap analysis and nucleus-specific bootstrap."}),"\n",(0,s.jsx)(n.h3,{id:"monte-carlo-simulations",children:"Monte Carlo simulations"}),"\n",(0,s.jsx)(n.p,{children:"For the Monte Carlo simulation, the fit is run once and Gaussian noise is added\nto the back-calculated values based on the error. Fits are subsequently run on\nthese generated profiles. After N simulations, the distribution of the fitted\nparameters provides an estimate of the uncertainty on the fitted parameters."}),"\n",(0,s.jsx)(n.h3,{id:"bootstrap-analysis",children:"Bootstrap analysis"}),"\n",(0,s.jsx)(n.p,{children:"The bootstrap analysis is similar to the Monte Carlo simulations, except that\nthe synthetic profiles are realized by randomly picking data points from each\nprofile to generate new ones with the same number of points as the original."}),"\n",(0,s.jsx)(n.h3,{id:"nucleus-specific-bootstrap-analysis",children:"Nucleus-specific bootstrap analysis"}),"\n",(0,s.jsx)(n.p,{children:"For the nucleus-specific bootstrap analysis, full profiles are randomly selected\nbased on their associated nucleus to generate the synthetic datasets. In other\nwords, if we have a dataset that depends on the nuclei {G2N, H8N, R9N, R9H},\npotential new datasets could include the profiles of the following sets of\nnuclei {H8N, H8N, R9N, R9H} or {G2N, G2N, G2N, R9H}."}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["Contrary to standard bootstrap analysis, nucleus-specific bootstrap analysis can\nproduce datasets with different number of data points in them. For examples, if\nprofiles depending on ",(0,s.jsx)(n.strong,{children:"H8N"})," appears in multiple experiments and the ones\ndepending on ",(0,s.jsx)(n.strong,{children:"G2N"})," in only one, then the two datasets mentioned above would\nhave different number of data points. This goes against the main principle\nunderlying bootstrap analysis that normally requires that all the newly sampled\ndatasets are of the same size."]})}),"\n",(0,s.jsx)(n.h3,{id:"syntax",children:"Syntax"}),"\n",(0,s.jsxs)(n.p,{children:["These calculations can be run at the end of any fitting step by using the key\n",(0,s.jsx)(n.code,{children:"STATISTICS"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"The syntax is the following:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-toml",children:'    [STEP1]\n    STATISTICS = {"MC"= 100}\n'})}),"\n",(0,s.jsx)(n.p,{children:"where MC is the type of simulation and 100 is the number of simulations."}),"\n",(0,s.jsx)(n.p,{children:"Types can be:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:'"MC" for Monte Carlo'}),"\n",(0,s.jsx)(n.li,{children:'"BS" for bootstrap'}),"\n",(0,s.jsx)(n.li,{children:'"BSN" for nucleus-specific bootstrap'}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"To run two or more types of simulation just add additional pairs of values:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-toml",children:'[STEP1]\nSTATISTICS = {"MC"= 100, "BS"= 100}\n'})}),"\n",(0,s.jsx)(n.p,{children:'The output for each kind of simulation is stored in a single file stored in the\ndirectory corresponding to the step it belongs to. Parameter values are stored\nin different columns. When no values are available, which can be the case for\nnucleus-specific bootstrap analysis, the characters "--" are used to fill the\nspace.'})]})}function c(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},1151:(e,n,i)=>{i.d(n,{Z:()=>o,a:()=>a});var s=i(7294);const t={},r=s.createContext(t);function a(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);